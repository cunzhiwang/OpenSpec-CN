/**
 * 技能模板工作流模块
 *
 * 此文件是通过将旧的单体模板文件拆分为以工作流为中心的模块而生成的。
 */
import type { SkillTemplate, CommandTemplate } from '../types.js';

export function getApplyChangeSkillTemplate(): SkillTemplate {
  return {
    name: 'openspec-apply-change',
    description: '从 OpenSpec 变更中实现任务。当用户想开始实现、继续实现或处理任务时使用。',
    instructions: `从 OpenSpec 变更中实现任务。

**输入**：可选指定变更名称。如果省略，检查是否可以从对话上下文推断。如果模糊或不明确，你必须提示可用的变更。

**步骤**

1. **选择变更**

   如果提供了名称，使用它。否则：
   - 如果用户在对话中提到变更，从上下文推断
   - 如果只有一个活跃变更，自动选择
   - 如果不明确，运行 \`openspec list --json\` 获取可用变更并使用 **AskUserQuestion 工具** 让用户选择

   始终宣布："使用变更：<name>" 以及如何覆盖（例如，\`/opsx:apply <other>\`）。

2. **检查状态以理解模式**
   \`\`\`bash
   openspec status --change "<name>" --json
   \`\`\`
   解析 JSON 以理解：
   - \`schemaName\`：使用的工作流（例如，"spec-driven"）
   - 哪个产物包含任务（spec-driven 通常是 "tasks"，其他模式检查状态）

3. **获取应用说明**

   \`\`\`bash
   openspec instructions apply --change "<name>" --json
   \`\`\`

   这返回：
   - 上下文文件路径（因模式而异 - 可能是 proposal/specs/design/tasks 或 spec/tests/implementation/docs）
   - 进度（总数、完成、剩余）
   - 带状态的任务列表
   - 基于当前状态的动态说明

   **处理状态：**
   - 如果 \`state: "blocked"\`（缺少产物）：显示消息，建议使用 openspec-continue-change
   - 如果 \`state: "all_done"\`：祝贺，建议归档
   - 否则：继续实现

4. **读取上下文文件**

   读取应用说明输出中 \`contextFiles\` 列出的文件。
   文件取决于使用的模式：
   - **spec-driven**：proposal、specs、design、tasks
   - 其他模式：遵循 CLI 输出中的 contextFiles

5. **显示当前进度**

   显示：
   - 使用的模式
   - 进度："N/M 任务完成"
   - 剩余任务概览
   - CLI 的动态说明

6. **实现任务（循环直到完成或阻塞）**

   对于每个待处理任务：
   - 显示正在处理哪个任务
   - 进行所需的代码更改
   - 保持更改最小化和专注
   - 在任务文件中标记任务完成：\`- [ ]\` → \`- [x]\`
   - 继续下一个任务

   **暂停如果：**
   - 任务不清楚 → 要求澄清
   - 实现揭示设计问题 → 建议更新产物
   - 遇到错误或阻塞 → 报告并等待指导
   - 用户中断

7. **完成或暂停时，显示状态**

   显示：
   - 本次会话完成的任务
   - 总体进度："N/M 任务完成"
   - 如果全部完成：建议归档
   - 如果暂停：解释原因并等待指导

**实现期间的输出**

\`\`\`
## 正在实现：<change-name>（模式：<schema-name>）

正在处理任务 3/7：<任务描述>
[...实现中...]
✓ 任务完成

正在处理任务 4/7：<任务描述>
[...实现中...]
✓ 任务完成
\`\`\`

**完成时的输出**

\`\`\`
## 实现完成

**变更：** <change-name>
**模式：** <schema-name>
**进度：** 7/7 任务完成 ✓

### 本次会话完成
- [x] 任务 1
- [x] 任务 2
...

所有任务完成！准备归档此变更。
\`\`\`

**暂停时的输出（遇到问题）**

\`\`\`
## 实现暂停

**变更：** <change-name>
**模式：** <schema-name>
**进度：** 4/7 任务完成

### 遇到的问题
<问题描述>

**选项：**
1. <选项 1>
2. <选项 2>
3. 其他方法

你想怎么做？
\`\`\`

**护栏**
- 继续处理任务直到完成或阻塞
- 开始前始终读取上下文文件（来自应用说明输出）
- 如果任务不明确，暂停并在实现前询问
- 如果实现揭示问题，暂停并建议更新产物
- 保持代码更改最小化并限定在每个任务范围内
- 完成每个任务后立即更新任务复选框
- 遇到错误、阻塞或不清楚的需求时暂停 - 不要猜测
- 使用 CLI 输出的 contextFiles，不要假设特定的文件名

**流畅工作流集成**

此技能支持"变更上的操作"模型：

- **可随时调用**：在所有产物完成之前（如果任务存在）、部分实现后、与其他操作交错
- **允许产物更新**：如果实现揭示设计问题，建议更新产物 - 不是阶段锁定，流畅工作`,
    license: 'MIT',
    compatibility: '需要 openspec CLI。',
    metadata: { author: 'openspec', version: '1.0' },
  };
}

export function getOpsxApplyCommandTemplate(): CommandTemplate {
  return {
    name: 'OPSX: 应用',
    description: '从 OpenSpec 变更中实现任务（实验性）',
    category: '工作流',
    tags: ['workflow', 'artifacts', 'experimental'],
    content: `从 OpenSpec 变更中实现任务。

**输入**：可选在 \`/opsx:apply\` 后指定变更名称（例如，\`/opsx:apply add-auth\`）。如果省略，检查是否可以从对话上下文推断。如果模糊或不明确，你必须提示可用的变更。

**步骤**

1. **选择变更**

   如果提供了名称，使用它。否则：
   - 如果用户在对话中提到变更，从上下文推断
   - 如果只有一个活跃变更，自动选择
   - 如果不明确，运行 \`openspec list --json\` 获取可用变更并使用 **AskUserQuestion 工具** 让用户选择

   始终宣布："使用变更：<name>" 以及如何覆盖（例如，\`/opsx:apply <other>\`）。

2. **检查状态以理解模式**
   \`\`\`bash
   openspec status --change "<name>" --json
   \`\`\`
   解析 JSON 以理解：
   - \`schemaName\`：使用的工作流（例如，"spec-driven"）
   - 哪个产物包含任务（spec-driven 通常是 "tasks"，其他模式检查状态）

3. **获取应用说明**

   \`\`\`bash
   openspec instructions apply --change "<name>" --json
   \`\`\`

   这返回：
   - 上下文文件路径（因模式而异）
   - 进度（总数、完成、剩余）
   - 带状态的任务列表
   - 基于当前状态的动态说明

   **处理状态：**
   - 如果 \`state: "blocked"\`（缺少产物）：显示消息，建议使用 \`/opsx:continue\`
   - 如果 \`state: "all_done"\`：祝贺，建议归档
   - 否则：继续实现

4. **读取上下文文件**

   读取应用说明输出中 \`contextFiles\` 列出的文件。
   文件取决于使用的模式：
   - **spec-driven**：proposal、specs、design、tasks
   - 其他模式：遵循 CLI 输出中的 contextFiles

5. **显示当前进度**

   显示：
   - 使用的模式
   - 进度："N/M 任务完成"
   - 剩余任务概览
   - CLI 的动态说明

6. **实现任务（循环直到完成或阻塞）**

   对于每个待处理任务：
   - 显示正在处理哪个任务
   - 进行所需的代码更改
   - 保持更改最小化和专注
   - 在任务文件中标记任务完成：\`- [ ]\` → \`- [x]\`
   - 继续下一个任务

   **暂停如果：**
   - 任务不清楚 → 要求澄清
   - 实现揭示设计问题 → 建议更新产物
   - 遇到错误或阻塞 → 报告并等待指导
   - 用户中断

7. **完成或暂停时，显示状态**

   显示：
   - 本次会话完成的任务
   - 总体进度："N/M 任务完成"
   - 如果全部完成：建议归档
   - 如果暂停：解释原因并等待指导

**实现期间的输出**

\`\`\`
## 正在实现：<change-name>（模式：<schema-name>）

正在处理任务 3/7：<任务描述>
[...实现中...]
✓ 任务完成

正在处理任务 4/7：<任务描述>
[...实现中...]
✓ 任务完成
\`\`\`

**完成时的输出**

\`\`\`
## 实现完成

**变更：** <change-name>
**模式：** <schema-name>
**进度：** 7/7 任务完成 ✓

### 本次会话完成
- [x] 任务 1
- [x] 任务 2
...

所有任务完成！你可以用 \`/opsx:archive\` 归档此变更。
\`\`\`

**暂停时的输出（遇到问题）**

\`\`\`
## 实现暂停

**变更：** <change-name>
**模式：** <schema-name>
**进度：** 4/7 任务完成

### 遇到的问题
<问题描述>

**选项：**
1. <选项 1>
2. <选项 2>
3. 其他方法

你想怎么做？
\`\`\`

**护栏**
- 继续处理任务直到完成或阻塞
- 开始前始终读取上下文文件（来自应用说明输出）
- 如果任务不明确，暂停并在实现前询问
- 如果实现揭示问题，暂停并建议更新产物
- 保持代码更改最小化并限定在每个任务范围内
- 完成每个任务后立即更新任务复选框
- 遇到错误、阻塞或不清楚的需求时暂停 - 不要猜测
- 使用 CLI 输出的 contextFiles，不要假设特定的文件名

**流畅工作流集成**

此技能支持"变更上的操作"模型：

- **可随时调用**：在所有产物完成之前（如果任务存在）、部分实现后、与其他操作交错
- **允许产物更新**：如果实现揭示设计问题，建议更新产物 - 不是阶段锁定，流畅工作`
  };
}
