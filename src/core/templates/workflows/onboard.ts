/**
 * 技能模板工作流模块
 *
 * 此文件是将旧版单体模板文件拆分为
 * 以工作流为中心的模块后生成的。
 */
import type { SkillTemplate, CommandTemplate } from '../types.js';

export function getOnboardSkillTemplate(): SkillTemplate {
  return {
    name: 'openspec-onboard',
    description: 'OpenSpec 引导入门 - 通过叙述和实际代码库工作来引导完成一个完整的工作流周期。',
    instructions: getOnboardInstructions(),
    license: 'MIT 许可证',
    compatibility: '需要 openspec CLI。',
    metadata: { author: 'openspec', version: '1.0' },
  };
}

function getOnboardInstructions(): string {
  return `引导用户完成他们的第一个完整的 OpenSpec 工作流周期。这是一次教学体验——你将在他们的代码库中进行实际工作，同时解释每个步骤。

---

## 预检

开始之前，检查 OpenSpec CLI 是否已安装：

\`\`\`bash
# Unix/macOS
openspec --version 2>&1 || echo "CLI_NOT_INSTALLED"
# Windows (PowerShell)
# if (Get-Command openspec -ErrorAction SilentlyContinue) { openspec --version } else { echo "CLI_NOT_INSTALLED" }
\`\`\`

**如果 CLI 未安装：**
> OpenSpec CLI 未安装。请先安装它，然后再回来使用 \`/opsx:onboard\`。

如果未安装，请在此停止。

---

## 阶段 1：欢迎

显示：

\`\`\`
## 欢迎来到 OpenSpec！

我将引导你完成一个完整的变更周期——从想法到实现——使用你代码库中的真实任务。在此过程中，你将通过实践来学习工作流。

**我们将要做的：**
1. 在你的代码库中选择一个小而真实的任务
2. 简要探索问题
3. 创建一个变更（我们工作的容器）
4. 构建工件：提案 → 规范 → 设计 → 任务
5. 实现任务
6. 归档已完成的变更

**时间：** ~15-20 分钟

让我们开始寻找要做的事情。
\`\`\`

---

## 阶段 2：任务选择

### 代码库分析

扫描代码库以寻找小的改进机会。寻找：

1. **TODO/FIXME 注释** - 在代码文件中搜索 \`TODO\`、\`FIXME\`、\`HACK\`、\`XXX\`
2. **缺少错误处理** - 吞没错误的 \`catch\` 块、没有 try-catch 的风险操作
3. **没有测试的函数** - 将 \`src/\` 与测试目录进行交叉引用
4. **类型问题** - TypeScript 文件中的 \`any\` 类型（\`: any\`、\`as any\`）
5. **调试残留** - 非调试代码中的 \`console.log\`、\`console.debug\`、\`debugger\` 语句
6. **缺少验证** - 没有验证的用户输入处理程序

还要检查最近的 git 活动：
\`\`\`bash
# Unix/macOS
git log --oneline -10 2>/dev/null || echo "No git history"
# Windows (PowerShell)
# git log --oneline -10 2>$null; if ($LASTEXITCODE -ne 0) { echo "No git history" }
\`\`\`

### 提出建议

根据你的分析，提出 3-4 个具体建议：

\`\`\`
## 任务建议

根据扫描你的代码库，以下是一些好的入门任务：

**1. [最有前景的任务]**
   位置：\`src/path/to/file.ts:42\`
   范围：~1-2 个文件，~20-30 行
   为什么好：[简要原因]

**2. [第二个任务]**
   位置：\`src/another/file.ts\`
   范围：~1 个文件，~15 行
   为什么好：[简要原因]

**3. [第三个任务]**
   位置：[位置]
   范围：[估计]
   为什么好：[简要原因]

**4. 其他？**
   告诉我你想做什么。

你对哪个任务感兴趣？（选择一个数字或描述你自己的）
\`\`\`

**如果没有发现任何东西：** 退而询问用户想要构建什么：
> 我没有在你的代码库中找到明显的快速改进点。你一直想添加或修复什么小东西？

### 范围保护

如果用户选择或描述的东西太大（主要功能、多天工作）：

\`\`\`
这是一个有价值的任务，但对于你第一次 OpenSpec 实践来说可能太大了。

为了学习工作流，越小越好——这让你可以看到完整的周期而不会陷入实现细节。

**选项：**
1. **切小一点** - [他们的任务] 中最小的有用部分是什么？也许只是 [具体切片]？
2. **选择其他** - 其他建议之一，或不同的小任务？
3. **无论如何都做** - 如果你真的想处理这个，我们可以。只是知道它会花更长时间。

你更喜欢什么？
\`\`\`

如果用户坚持，让他们覆盖——这是一个软保护。

---

## 阶段 3：探索演示

一旦选择了任务，简要演示探索模式：

\`\`\`
在我们创建变更之前，让我快速向你展示**探索模式**——这是你在承诺方向之前思考问题的方式。
\`\`\`

花 1-2 分钟调查相关代码：
- 读取涉及的文件
- 如果有帮助，画一个快速的 ASCII 图表
- 注意任何考虑因素

\`\`\`
## 快速探索

[你的简要分析——你发现了什么，有什么考虑]

┌─────────────────────────────────────────┐
│   [可选：如果有帮助的 ASCII 图表]        │
└─────────────────────────────────────────┘

探索模式（\`/opsx:explore\`）就是用于这种思考——在实现之前调查。你可以在任何需要思考问题的时候使用它。

现在让我们创建一个变更来保存我们的工作。
\`\`\`

**暂停** - 在继续之前等待用户确认。

---

## 阶段 4：创建变更

**解释：**
\`\`\`
## 创建变更

OpenSpec 中的"变更"是一个容器，用于保存围绕一项工作的所有思考和规划。它位于 \`openspec/changes/<name>/\`，包含你的工件——提案、规范、设计、任务。

让我为我们的任务创建一个。
\`\`\`

**执行：** 使用派生的 kebab-case 名称创建变更：
\`\`\`bash
openspec new change "<derived-name>"
\`\`\`

**展示：**
\`\`\`
已创建：\`openspec/changes/<name>/\`

文件夹结构：
\`\`\`
openspec/changes/<name>/
├── proposal.md    ← 我们为什么要这样做（空的，我们会填写）
├── design.md      ← 我们将如何构建它（空的）
├── specs/         ← 详细需求（空的）
└── tasks.md       ← 实现清单（空的）
\`\`\`

现在让我们填写第一个工件——提案。
\`\`\`

---

## 阶段 5：提案

**解释：**
\`\`\`
## 提案

提案捕获我们进行此变更的**原因**以及在高层次上**涉及什么**。它是工作的"电梯演讲"。

我将根据我们的任务起草一个。
\`\`\`

**执行：** 起草提案内容（先不保存）：

\`\`\`
这是提案草稿：

---

## 为什么

[1-2 句话解释问题/机会]

## 什么变化

[将要改变的要点]

## 能力

### 新能力
- \`<capability-name>\`：[简要描述]

### 修改的能力
<!-- 如果修改现有行为 -->

## 影响

- \`src/path/to/file.ts\`：[什么变化]
- [其他文件（如果适用）]

---

这是否捕获了意图？我可以在保存之前进行调整。
\`\`\`

**暂停** - 等待用户批准/反馈。

批准后，保存提案：
\`\`\`bash
openspec instructions proposal --change "<name>" --json
\`\`\`
然后将内容写入 \`openspec/changes/<name>/proposal.md\`。

\`\`\`
提案已保存。这是你的"为什么"文档——随着理解的发展，你可以随时回来完善它。

接下来：规范。
\`\`\`

---

## 阶段 6：规范

**解释：**
\`\`\`
## 规范

规范以精确、可测试的术语定义我们正在构建**什么**。它们使用需求/场景格式，使预期行为清晰明了。

对于像这样的小任务，我们可能只需要一个规范文件。
\`\`\`

**执行：** 创建规范文件：
\`\`\`bash
# Unix/macOS
mkdir -p openspec/changes/<name>/specs/<capability-name>
# Windows (PowerShell)
# New-Item -ItemType Directory -Force -Path "openspec/changes/<name>/specs/<capability-name>"
\`\`\`

起草规范内容：

\`\`\`
这是规范：

---

## 新增需求

### 需求：<名称>

<描述系统应该做什么>

#### 场景：<场景名称>

- **当** <触发条件>
- **那么** <预期结果>
- **并且** <如果需要的额外结果>

---

这种格式——当/那么/并且——使需求可测试。你可以直接把它们当作测试用例来读。
\`\`\`

保存到 \`openspec/changes/<name>/specs/<capability>/spec.md\`。

---

## 阶段 7：设计

**解释：**
\`\`\`
## 设计

设计捕获我们将**如何**构建它——技术决策、权衡、方法。

对于小的变更，这可能很简短。没关系——不是每个变更都需要深入的设计讨论。
\`\`\`

**执行：** 起草 design.md：

\`\`\`
这是设计：

---

## 背景

[关于当前状态的简要背景]

## 目标 / 非目标

**目标：**
- [我们试图实现什么]

**非目标：**
- [明确超出范围的内容]

## 决策

### 决策 1：[关键决策]

[方法和理由的解释]

---

对于小任务，这捕获了关键决策而不会过度工程化。
\`\`\`

保存到 \`openspec/changes/<name>/design.md\`。

---

## 阶段 8：任务

**解释：**
\`\`\`
## 任务

最后，我们将工作分解为实现任务——驱动应用阶段的复选框。

这些应该是小的、清晰的，并按逻辑顺序排列。
\`\`\`

**执行：** 根据规范和设计生成任务：

\`\`\`
这是实现任务：

---

## 1. [类别或文件]

- [ ] 1.1 [具体任务]
- [ ] 1.2 [具体任务]

## 2. 验证

- [ ] 2.1 [验证步骤]

---

每个复选框在应用阶段成为一个工作单元。准备好实现了吗？
\`\`\`

**暂停** - 等待用户确认他们准备好实现。

保存到 \`openspec/changes/<name>/tasks.md\`。

---

## 阶段 9：应用（实现）

**解释：**
\`\`\`
## 实现

现在我们实现每个任务，完成后打勾。我会宣布每一个，并偶尔说明规范/设计如何影响方法。
\`\`\`

**执行：** 对于每个任务：

1. 宣布："正在处理任务 N：[描述]"
2. 在代码库中实现变更
3. 自然地引用规范/设计："规范说 X，所以我做 Y"
4. 在 tasks.md 中标记完成：\`- [ ]\` → \`- [x]\`
5. 简短状态："✓ 任务 N 完成"

保持叙述轻松——不要过度解释每一行代码。

所有任务完成后：

\`\`\`
## 实现完成

所有任务完成：
- [x] 任务 1
- [x] 任务 2
- [x] ...

变更已实现！还有一步——让我们归档它。
\`\`\`

---

## 阶段 10：归档

**解释：**
\`\`\`
## 归档

当变更完成时，我们将其归档。这会将它从 \`openspec/changes/\` 移动到 \`openspec/changes/archive/YYYY-MM-DD-<name>/\`。

归档的变更成为你项目的决策历史——你可以随时找到它们来理解为什么某些东西是以某种方式构建的。
\`\`\`

**执行：**
\`\`\`bash
openspec archive "<name>"
\`\`\`

**展示：**
\`\`\`
已归档到：\`openspec/changes/archive/YYYY-MM-DD-<name>/\`

变更现在是你项目历史的一部分。代码在你的代码库中，决策记录已保存。
\`\`\`

---

## 阶段 11：回顾和下一步

\`\`\`
## 恭喜！

你刚刚完成了一个完整的 OpenSpec 周期：

1. **探索** - 思考问题
2. **新建** - 创建变更容器
3. **提案** - 捕获为什么
4. **规范** - 详细定义什么
5. **设计** - 决定如何
6. **任务** - 分解为步骤
7. **应用** - 实现工作
8. **归档** - 保存记录

同样的节奏适用于任何规模的变更——小修复或大功能。

---

## 命令参考

**核心工作流：**

| 命令 | 作用 |
|------|------|
| \`/opsx:propose\` | 创建变更并生成所有工件 |
| \`/opsx:explore\` | 在工作之前/期间思考问题 |
| \`/opsx:apply\` | 从变更中实现任务 |
| \`/opsx:archive\` | 归档已完成的变更 |

**额外命令：**

| 命令 | 作用 |
|------|------|
| \`/opsx:new\` | 开始新变更，逐步完成工件 |
| \`/opsx:continue\` | 继续处理现有变更 |
| \`/opsx:ff\` | 快进：一次创建所有工件 |
| \`/opsx:verify\` | 验证实现是否匹配工件 |

---

## 下一步？

尝试 \`/opsx:propose\` 来处理你真正想构建的东西。你现在已经掌握了节奏！
\`\`\`

---

## 优雅退出处理

### 用户想中途停止

如果用户说他们需要停止、想暂停或似乎不感兴趣：

\`\`\`
没问题！你的变更已保存在 \`openspec/changes/<name>/\`。

以后要继续从中断处继续：
- \`/opsx:continue <name>\` - 恢复工件创建
- \`/opsx:apply <name>\` - 跳到实现（如果任务存在）

工作不会丢失。准备好了随时回来。
\`\`\`

优雅地退出，不施加压力。

### 用户只想要命令参考

如果用户说他们只想看命令或跳过教程：

\`\`\`
## OpenSpec 快速参考

**核心工作流：**

| 命令 | 作用 |
|------|------|
| \`/opsx:propose <name>\` | 创建变更并生成所有工件 |
| \`/opsx:explore\` | 思考问题（不修改代码） |
| \`/opsx:apply <name>\` | 实现任务 |
| \`/opsx:archive <name>\` | 完成后归档 |

**额外命令：**

| 命令 | 作用 |
|------|------|
| \`/opsx:new <name>\` | 开始新变更，逐步进行 |
| \`/opsx:continue <name>\` | 继续现有变更 |
| \`/opsx:ff <name>\` | 快进：一次生成所有工件 |
| \`/opsx:verify <name>\` | 验证实现 |

尝试 \`/opsx:propose\` 开始你的第一个变更。
\`\`\`

优雅地退出。

---

## 护栏

- **在关键转换点遵循 解释 → 执行 → 展示 → 暂停 模式**（探索后、提案草稿后、任务后、归档后）
- **保持叙述轻松** 在实现期间——教而不讲
- **不要跳过阶段** 即使变更很小——目标是教授工作流
- **在标记点暂停等待确认**，但不要过度暂停
- **优雅处理退出**——永远不要强迫用户继续
- **使用真实代码库任务**——不要模拟或使用假示例
- **温和调整范围**——引导向较小任务但尊重用户选择`;
}

export function getOpsxOnboardCommandTemplate(): CommandTemplate {
  return {
    name: 'OPSX: 入门引导',
    description: '引导入门 - 通过叙述完成一个完整的 OpenSpec 工作流周期',
    category: '工作流',
    tags: ['workflow', 'onboarding', 'tutorial', 'learning'],
    content: getOnboardInstructions(),
  };
}
